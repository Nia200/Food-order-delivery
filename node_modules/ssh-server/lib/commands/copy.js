"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ssh_base_1 = require("../lib/ssh-base");
const child_process = require("child_process");
const sshpass_1 = require("../lib/sshpass");
const cmd_1 = require("@troubkit/cmd");
const log_1 = require("@troubkit/log");
const command_1 = require("@oclif/command");
class Copy extends ssh_base_1.default {
    async run() {
        const { argv, flags } = this.parse(Copy);
        if (argv.length < 2) {
            console.log(Copy.help);
        }
        const sources = argv.slice(0, argv.length - 1);
        let target = argv[argv.length - 1];
        let cmd = new cmd_1.Command("scp");
        if (flags.recursive) {
            cmd.append("-r");
        }
        const transformRemote = (remotePath, first) => {
            var _a;
            const secs = remotePath.split(":");
            if (secs.length <= 1) {
                return undefined;
            }
            const server = secs[0];
            const config = super.parseServerConfig(server, flags);
            if (first) {
                if (config.identityFile) {
                    cmd.append("-i", config.identityFile);
                }
                else if (config.password) {
                    cmd = sshpass_1.getOrInstallSshpass()
                        .append("-p", config.password)
                        .append(cmd.toString());
                }
                cmd.append("-P", `${(_a = config.port) !== null && _a !== void 0 ? _a : 22}`);
            }
            return `${config.username}@${config.host}:${secs[1]}`;
        };
        let sourceRemote = false;
        let first = true;
        for (let i = 0; i < sources.length; i++) {
            const source = sources[i];
            const transformed = transformRemote(source, first);
            if (transformed) {
                sources[i] = transformed;
                sourceRemote = true;
                first = false;
            }
        }
        let targetRemote = false;
        const transformed = transformRemote(target, first);
        if (transformed) {
            target = transformed;
            targetRemote = true;
        }
        if (sourceRemote && targetRemote) {
            cmd.append("-3");
        }
        cmd.append(...sources, target);
        console.log("$", cmd.toString());
        const r = child_process.spawnSync(cmd.command, cmd.args, {
            stdio: "inherit",
            env: process.env,
        });
        if (!r) {
            return;
        }
        if (r.error) {
            throw r.error;
        }
        if (r.status != 0) {
            throw new Error("process exit with code " + r.status);
        }
    }
}
exports.default = Copy;
Copy.aliases = ["cp"];
Copy.description = "open server shell";
Copy.examples = [
    "$ ssh-server copy -r server:~/workspace ~/",
];
Copy.flags = Object.assign(ssh_base_1.default.flags, {
    recursive: command_1.flags.boolean({ char: "r", description: "recursive copy" }),
});
Copy.args = [
    { name: "source" },
    { name: "..." },
    { name: "target" },
];
Copy.logger = new log_1.ContextLogger("Copy");
//# sourceMappingURL=copy.js.map